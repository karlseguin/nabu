// An in-memory set-based document database
package nabu

import (
  "fmt"
  "sync"
  "encoding/json"
  "github.com/karlseguin/nabu/key"
  "github.com/karlseguin/nabu/cache"
  "github.com/karlseguin/nabu/indexes"
  "github.com/karlseguin/nabu/storage"
)

/*
Factory is used to recreate documents from the persisted
representations. Data is a []byte array which was encoded using
encoding/json. If you have a single type of document, a simple
factory will suffice:

   func factory(id key.Type, data []byte) nabu.Document {
     product := new(Product)
     if err := json.Unmarshal(data, &tree); err != nil {
       panic(err)
     }
     return product
   }

If you have multiple documents, you'll either use the id or
information within the data itself to determine the type.
(whether or not you can use the id depends on whether your system
allows you to infer the type based on the id).

   func factory(id key.Type, data []byte) nabu.Document {
     var m map[string]interface{}
     if err := json.Unmarshal(data, &m); err != nil {
       panic(err)
     }
     type := m["type"].(string)
     if type == "Product" {
       ...
     } else if .... {
       ...
     }
   }
*/
type Factory func(id key.Type, data []byte) Document

// Database is the primary point of interaction with Nabu
type Database struct {
  loading bool
  *Configuration
  cache *cache.Cache
  queryPool chan *Query
  sortLock sync.RWMutex
  buckets map[int]*Bucket
  iStorage storage.Storage
  dStorage storage.Storage
  indexLock sync.RWMutex
  sorts map[string]indexes.Sort
  sortedResults chan *SortedResult
  indexes map[string]*indexes.Index
  unsortedResults chan *UnsortedResult
}

// Creates a new Database instance. Unless configured to SkipLoad, data from
// the storage path will be restored
func New(c *Configuration) *Database {
  db := &Database {
    Configuration: c,
    sorts: make(map[string]indexes.Sort),
    indexes: make(map[string]*indexes.Index),
    iStorage: storage.New(c.dbPath + "indexes"),
    dStorage: storage.New(c.dbPath + "documents"),
    queryPool: make(chan *Query, c.queryPoolSize),
    buckets: make(map[int]*Bucket, c.bucketCount),
    sortedResults: make(chan *SortedResult, c.sortedResultPoolSize),
    unsortedResults: make(chan *UnsortedResult, c.unsortedResultPoolSize),
  }
  db.cache = cache.New(db, db.cacheWorkers)
  for i := 0; i < int(c.bucketCount); i++ {
    db.buckets[i] = &Bucket{lookup: make(map[key.Type]Document),}
  }
  for i := 0; i < c.queryPoolSize; i++ {
    newQuery(db) //it automatically enqueues itself
  }
  for i := 0; i < c.sortedResultPoolSize; i++ {
    db.sortedResults <- newSortedResult(db)
  }
  for i := 0; i < c.unsortedResultPoolSize; i++ {
    db.unsortedResults <- newUnsortedResult(db)
  }

  if c.skipLoad == false {
    db.restore()
  }
  return db
}

// Generate a Query object against the specified sort index
func (d *Database) Query(sortName string) *Query {
  d.sortLock.RLock()
  sort, exists := d.sorts[sortName]
  d.sortLock.RUnlock()
  if exists == false {
    panic(fmt.Sprintf("unknown sort index %q", sortName))
  }
  q := <-d.queryPool
  q.sort = sort
  return q
}

// Loads a static sort. Static sorts are ideal for infrequently
// changed sorts, such as those generated by background processes.
// Statis sorts are less flexible, but more efficient.
func (d *Database) LoadSort(sortName string, ids []key.Type) {
  d.getOrCreateSort(sortName, len(ids)).Load(ids)
  if d.loading == false {
    d.iStorage.Put([]byte(sortName), serializeValue(ids))
  }
}

// Appends a value to the specified sort. This can be used against
// either a dynamic or static sort. This isn't particularly efficient
// when used against a static sort, though occasional use is encouraged.
func (d *Database) AppendSort(sortName string, id key.Type) {
  d.getOrCreateSort(sortName, -1).Append(id)
}

// Prepends a value to the specified sort. See the notes on AppendSort
// for more details
func (d *Database) PrependSort(sortName string, id key.Type) {
  d.getOrCreateSort(sortName, -1).Prepend(id)
}

// Retrieves a document by id
func (d *Database) Get(id key.Type) Document {
  return d.getFromBucket(id, d.getBucket(id))
}

// Inserts or updates the document
func (d *Database) Update(doc Document) {
  meta := newMeta()
  doc.ReadMeta(meta)
  bucket := d.getBucket(meta.id)
  if old := d.getMeta(meta.id, bucket); old == nil {
    d.insert(doc, meta, bucket)
  } else {
    d.update(doc, meta, old, bucket)
  }
  for sort, rank := range meta.sorts {
    d.addDocumentSort(sort, meta.id, rank)
  }
  if d.loading == false {
    idBuffer := meta.id.Serialize()
    defer idBuffer.Close()
    d.dStorage.Put(idBuffer.Bytes(), serializeValue(doc))
  }
}

// Removes the document. Safe to call even if the document
// does not exists.
func (d *Database) Remove(doc Document) {
  meta := newMeta()
  doc.ReadMeta(meta)
  id := meta.id
  for index, _ := range meta.indexes {
    d.removeDocumentIndex(index, id)
  }
  for sort, _ := range meta.sorts {
    d.removeDocumentSort(sort, id)
  }
  d.removeDocument(doc, id)
  if d.loading == false {
    idBuffer := id.Serialize()
    defer idBuffer.Close()
    d.dStorage.Remove(idBuffer.Bytes())
  }
}

// Removes to the document by id. Safe to call even if the
// id doesn't exist
func (d *Database) RemoveById(id key.Type) {
  bucket := d.getBucket(id)
  doc := d.getFromBucket(id, bucket)
  if doc != nil {
    d.Remove(doc)
  }
}

// Closes the database
func (d *Database) Close() error {
  derr := d.dStorage.Close()
  ierr := d.iStorage.Close()
  if derr != nil { return derr }
  return ierr
}

// Gets a document's meta details based on an id
func (d *Database) getMeta(id key.Type, bucket int) *Meta {
  doc := d.getFromBucket(id, bucket)
  if doc == nil { return nil }
  meta := newMeta()
  doc.ReadMeta(meta)
  return meta
}


// Gets a document from the given bucket
func (d *Database) getFromBucket(id key.Type, index int) Document {
  bucket := d.buckets[index]
  bucket.RLock()
  defer bucket.RUnlock()
  return bucket.lookup[id]
}

// Gets the document's bucket
func (d *Database) getBucket(key key.Type) int {
  return key.Bucket(d.bucketCount)
}

// Inserts a new document
func (d *Database) insert(doc Document, meta *Meta, bucket int) {
  id := meta.id
  for index, _ := range meta.indexes {
    d.addDocumentIndex(index, id)
  }
  d.addDocument(doc, id, bucket)
}

// Updates an existing document
func (d *Database) update(doc Document, meta *Meta, old *Meta, bucket int) {
  id := meta.id

  for index, _ := range meta.indexes {
    if _, exists := old.indexes[index]; exists {
      delete(old.indexes, index)
    } else {
      d.addDocumentIndex(index, id)
    }
  }
  for index, _ := range old.indexes {
    d.removeDocumentIndex(index, id)
  }
  d.addDocument(doc, id, bucket)
}

// Indexes the document
func (d *Database) addDocumentIndex(indexName string, id key.Type) {
  d.indexLock.RLock()
  index, exists := d.indexes[indexName]
  d.indexLock.RUnlock()
  if exists == false {
    d.indexLock.Lock()
    index, exists = d.indexes[indexName]
    if exists == false {
      index = indexes.New(indexName)
      d.indexes[indexName] = index
    }
    d.indexLock.Unlock()
  }
  index.Add(id)
  d.changed(indexName, id, true)
}

// Sort indexes the document
func (d *Database) addDocumentSort(sortName string, id key.Type, rank int) {
  d.getOrCreateSort(sortName, -1).(indexes.DynamicSort).Set(id, rank)
}


// Gets the sort index, or creates it if it doesn't already exists
func (d *Database) getOrCreateSort(sortName string, length int) indexes.Sort {
  d.sortLock.RLock()
  sort, exists := d.sorts[sortName]
  d.sortLock.RUnlock()
  if exists { return sort }

  d.sortLock.Lock()
  defer d.sortLock.Unlock()
  sort, exists = d.sorts[sortName]
  if exists == false {
    sort = indexes.NewSort(length, d.maxUnsortedSize)
    d.sorts[sortName] = sort
  }
  return sort
}

// Unindexes the document
func (d *Database) removeDocumentIndex(indexName string, id key.Type) {
  d.indexLock.RLock()
  index, exists := d.indexes[indexName]
  d.indexLock.RUnlock()
  if exists == false { return }
  index.Remove(id)
  d.changed(indexName, id, false)
}

// Removes the sort indexes for the document
func (d *Database) removeDocumentSort(sortName string, id key.Type) {
  d.sortLock.RLock()
  sort, exists := d.sorts[sortName]
  d.sortLock.RUnlock()
  if exists == false { return }
  sort.(indexes.DynamicSort).Remove(id)
}

// Adds the document to the bucket
func (d *Database) addDocument(doc Document, id key.Type, index int) {
  bucket := d.buckets[index]
  bucket.Lock()
  defer bucket.Unlock()
  bucket.lookup[id] = doc
}

// Removes the document from the bucket
func (d *Database) removeDocument(doc Document, id key.Type) {
  index := d.getBucket(id)
  bucket := d.buckets[index]
  bucket.Lock()
  defer bucket.Unlock()
  delete(bucket.lookup, id)
}

// Signal the cache that an index was updated with a specific id
func (d *Database) changed(indexName string, id key.Type, updated bool) {
  if d.loading == false {
    d.cache.Changed(indexName, id, updated)
  }
}

// Loads documents and indexes from the storage engine
func (d *Database) restore() {
  d.loading = true
  iter := d.dStorage.Iterator()
  for iter.Next() {
    id, value := iter.Current()
    d.Update(d.factory(key.Deserialize(id), value))
  }
  iter = d.iStorage.Iterator()
  for iter.Next() {
    id, value := iter.Current()
    d.LoadSort(string(id), deserializeIndex(value))
  }
  d.loading = false
}

// Callback used to load indexes from index names
func (d *Database) LookupIndexes(indexNames []string, target indexes.Indexes) bool {
  ok := true
  d.indexLock.RLock()
  d.indexLock.RUnlock()
  for i, name := range indexNames {
    index, exists := d.indexes[name]
    target[i] = index
    if exists == false { ok = false }
  }
  return ok
}

// Serialize values to be passed to the storage engine
func serializeValue(value interface{}) []byte {
  serialized, err := json.Marshal(value)
  if err != nil { panic(err) }
  return serialized
}

// Deserializes an indexes from the storage engine
func deserializeIndex(raw []byte) []key.Type {
  var index []key.Type
  if err := json.Unmarshal(raw, &index); err != nil {
    panic(err)
  }
  return index
}
